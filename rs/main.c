#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>

// an element in GF(2^8)
typedef uint8_t field_element_t;

// a power of the primitive element alpha
typedef uint8_t field_logarithm_t;

// give us some bits of headroom to do arithmetic
// variables of this type aren't really in any proper space
typedef uint16_t field_operation_t;

// generated by find_poly
const field_operation_t primitive_polynomial_8_4_3_2_0 = 0x11d;  // x^8 + x^4 + x^3 + x^2 + 1
const field_operation_t primitive_polynomial_8_5_3_1_0 = 0x12b;  // x^8 + x^5 + x^3 + x + 1
const field_operation_t primitive_polynomial_8_5_3_2_0 = 0x12d;  // x^8 + x^5 + x^3 + x^2 + 1
const field_operation_t primitive_polynomial_8_6_3_2_0 = 0x14d;  // x^8 + x^6 + x^3 + x^2 + 1
const field_operation_t primitive_polynomial_8_6_4_3_2_1_0 = 0x15f;  // x^8 + x^6 + x^4 + x^3 + x^2 + x + 1;
const field_operation_t primitive_polynomial_8_6_5_1_0 = 0x163;  // x^8 + x^6 + x^5 + x + 1
const field_operation_t primitive_polynomial_8_6_5_2_0 = 0x165;  // x^8 + x^6 + x^5 + x^2 + 1
const field_operation_t primitive_polynomial_8_6_5_3_0 = 0x169;  // x^8 + x^6 + x^5 + x^3 + 1
const field_operation_t primitive_polynomial_8_6_5_4_0 = 0x171;  // x^8 + x^6 + x^5 + x^4 + 1
const field_operation_t primitive_polynomial_8_7_2_1_0 = 0x187;  // x^8 + x^7 + x^2 + x + 1
const field_operation_t primitive_polynomial_8_7_3_2_0 = 0x18d;  // x^8 + x^7 + x^3 + x^2 + 1
const field_operation_t primitive_polynomial_8_7_5_3_0 = 0x1a9;  // x^8 + x^7 + x^5 + x^3 + 1
const field_operation_t primitive_polynomial_8_7_6_1_0 = 0x1c3;  // x^8 + x^7 + x^6 + x + 1
const field_operation_t primitive_polynomial_8_7_6_3_2_1_0 = 0x1cf;  // x^8 + x^7 + x^6 + x^3 + x^2 + x + 1
const field_operation_t primitive_polynomial_8_7_6_5_2_1_0 = 0x1e7;  // x^8 + x^7 + x^6 + x^5 + x^2 + x + 1
const field_operation_t primitive_polynomial_8_7_6_5_4_2_0 = 0x1f5;  // x^8 + x^7 + x^6 + x^5 + x^4 + x^2 + 1

const field_operation_t primitive_polynomial_ccsds = primitive_polynomial_8_7_2_1_0;

typedef struct {
    const field_element_t *exp;
    const field_logarithm_t *log;
} field_t;

field_t field_create(field_operation_t poly) {
    // in GF(2^8)
    // log and exp
    // bits are in GF(2), compute alpha^val in GF(2^8)
    // exp should be of size 512 so that it can hold a "wraparound" which prevents some modulo ops
    // log should be of size 256. no wraparound here, the indices into this table are field elements
    field_element_t *exp = malloc(512 * sizeof(field_element_t));
    field_logarithm_t *log = malloc(256 * sizeof(field_logarithm_t));

    // assume alpha is a primitive element, p(x) irreducible in GF(2^8)
    // addition is xor
    // subtraction is addition (also xor)
    // e.g. x^5 + x^4 + x^4 + x^2 + 1 = x^5 + x^2 + 1
    // each row of exp contains the field element found by exponentiating
    //   alpha by the row index
    // each row of log contains the coefficients of
    //   alpha^7 + alpha^6 + alpha^5 + alpha^4 + alpha^3 + alpha^2 + alpha + 1
    // as 8 bits packed into one byte

    field_operation_t element = 1;
    exp[0] = (field_element_t)element;
    log[0] = (field_logarithm_t)0;  // really, it's undefined. we shouldn't ever access this
    for (field_operation_t i = 1; i < 512; i++) {
        element = element * 2;
        element = (element > 255) ? (element ^ poly) : element;
        exp[i] = (field_element_t)element;
        if (i < 256) {
            log[element] = (field_logarithm_t)i;
        }
    }

    field_t field;
    *(field_element_t **)&field.exp = exp;
    *(field_logarithm_t **)&field.log = log;

    return field;
}

void field_destroy(field_t field) {
    free(*(field_element_t **)&field.exp);
    free(*(field_element_t **)&field.log);
}

field_element_t field_add(field_t field, field_element_t l, field_element_t r) {
    return l ^ r;
}

field_element_t field_sub(field_t field, field_element_t l, field_element_t r) {
    return l ^ r;
}

field_element_t field_sum(field_t field, field_element_t elem, unsigned int n) {
    // we'll do a closed-form expression of the sum, although we could also
    //   choose to call field_add n times

    // since the sum is actually the bytewise XOR operator, this suggests two
    // kinds of values: n odd, and n even

    // if you sum once, you have coeff
    // if you sum twice, you have coeff XOR coeff = 0
    // if you sum thrice, you are back at coeff
    // an even number of XORs puts you at 0
    // an odd number of XORs puts you back at your value

    // so, just throw away all the even n
    return (n % 2) ? elem : 0;
}

field_element_t field_mul(field_t field, field_element_t l, field_element_t r) {
    if (l == 0 || r == 0) {
        return 0;
    }
    // multiply two field elements by adding their logarithms.
    // yep, get your slide rules out
    field_operation_t res = (field_operation_t)field.log[l] + (field_operation_t)field.log[r];

    // if coeff exceeds 255, we would normally have to wrap it back around
    // alpha^255 = 1; alpha^256 = alpha^255 * alpha^1 = alpha^1
    // however, we've constructed exponentiation table so that
    //   we can just directly lookup this result
    // the result must be clamped to [0, 511]
    // the greatest we can see at this step is alpha^255 * alpha^255
    //   = alpha^510
    return field.exp[res];
}

field_element_t field_div(field_t field, field_element_t l, field_element_t r) {
    if (l == 0) {
        return 0;
    }

    if (r == 0) {
        // XXX ???
        return 0;
    }

    // division as subtraction of logarithms

    // if rcoeff is larger, then log[l] - log[r] wraps under
    // so, instead, always add 255. in some cases, we'll wrap over, but
    // that's ok because the exp table runs up to 511.
    field_operation_t res = (field_operation_t)255 + (field_operation_t)field.log[l] - (field_operation_t)field.log[r];
    return field.exp[res];
}

field_logarithm_t field_mul_log(field_t field, field_logarithm_t l, field_logarithm_t r) {
    field_operation_t res = (field_operation_t)l + (field_operation_t)r;
    if (res > 255) {
        return (field_logarithm_t)(res - 255);
    }
    return (field_logarithm_t)res;
}

field_logarithm_t field_div_log(field_t field, field_logarithm_t l, field_logarithm_t r) {
    field_operation_t res = (field_operation_t)255 + (field_operation_t)l - (field_operation_t)r;
    if (res > 255) {
        return (field_logarithm_t)(res - 255);
    }
    return (field_logarithm_t)res;
}

field_element_t field_mul_log_element(field_t field, field_logarithm_t l, field_logarithm_t r) {
    field_operation_t res = (field_operation_t)l + (field_operation_t)r;
    return field.exp[res];
}

/*
unsigned short powcoeff(unsigned short coeff, unsigned int pow, const unsigned short *exp,
                        const unsigned short *log) {
    // take the logarithm, multiply, and then "exponentiate"
    // n.b. the exp table only considers powers of alpha, the primitive element
    // but here we have an arbitray coeff
    coeff = log[coeff];
    unsigned int rescoeff = coeff * pow;
    unsigned int nwraps = rescoeff / 256;
    unsigned int mod = rescoeff % 256;
    nwraps = (mod > 0) ? nwraps + 1 : nwraps;
    rescoeff = mod

}
*/

typedef struct {
    field_element_t *coeff;
    unsigned int order;
} polynomial_t;

polynomial_t polynomial_create(unsigned int order) {
    polynomial_t polynomial;
    polynomial.coeff = malloc(sizeof(field_element_t) * (order + 1));
    polynomial.order = order;
    return polynomial;
}

void polynomial_destroy(polynomial_t polynomial) {
    free(polynomial.coeff);
}

// if you want a full multiplication, then make res.order = l.order + r.order
// but if you just care about a lower order, e.g. mul mod x^i, then you can select
//    fewer coefficients
void polynomial_mul(field_t field, polynomial_t l, polynomial_t r, polynomial_t res) {
    memset(res.coeff, 0, sizeof(field_element_t) * (res.order + 1));
    for (unsigned int i = 0; i <= l.order; i++) {
        if (i > res.order) {
            continue;
        }
        unsigned int j_limit = (r.order > res.order - i) ? res.order - i : r.order;
        for (unsigned int j = 0; j <= j_limit; j++) {
            // e.g. alpha^5*x * alpha^37*x^2 --> alpha^42*x^3
            res.coeff[i + j] = field_add(field, res.coeff[i + j], field_mul(field, l.coeff[i], r.coeff[j]));
        }
    }
}

void polynomial_mod(field_t field, polynomial_t dividend, polynomial_t divisor, polynomial_t mod) {
    // do long division and return just the remainder

    if (mod.order < dividend.order) {
        printf("polynomial_mod: mod.order must be >= dividend.order (scratch space needed)");
        return;
    }
    // initialize remainder as dividend
    memcpy(mod.coeff, dividend.coeff, sizeof(field_element_t) * (dividend.order + 1));

    // XXX make sure divisor[divisor_order] is nonzero
    field_logarithm_t divisor_leading = field.log[divisor.coeff[divisor.order]];
    // long division steps along one order at a time, starting at the highest order
    for (unsigned int i = dividend.order; i > 0; i--) {
        // look at the leading coefficient of dividend and divisor
        // if leading coefficient of dividend / leading coefficient of divisor is q
        //   then the next row of subtraction will be q * divisor
        // if order of q < 0 then what we have is the remainder and we are done
        if (i < divisor.order) {
            break;
        }
        if (mod.coeff[i] == 0) {
            continue;
        }
        unsigned int q_order = i - divisor.order;
        field_logarithm_t q_coeff = field_div_log(field, field.log[mod.coeff[i]], divisor_leading);

        // now that we've chosen q, multiply the divisor by q and subtract from
        //   our remainder. subtracting in GF(2^8) is XOR, just like addition
        for (unsigned int j = 0; j <= divisor.order; j++) {
            if (divisor.coeff[j] == 0) {
                continue;
            }
            // all of the multiplication is shifted up by q_order places
            mod.coeff[j + q_order] = field_add(field, mod.coeff[j + q_order],
                        field_mul_log_element(field, field.log[divisor.coeff[j]], q_coeff));
        }
    }
}

void polynomial_formal_derivative(field_t field, polynomial_t poly, polynomial_t der) {
    // if f(x) = a(n)*x^n + ... + a(1)*x + a(0)
    // then f'(x) = n*a(n)*x^(n-1) + ... + 2*a(2)*x + a(1)
    // where n*a(n) = sum(k=1, n, a(n)) e.g. the nth sum of a(n) in GF(2^8)

    // assumes der.order = poly.order - 1
    memset(der.coeff, 0, sizeof(field_element_t) * poly.order);
    for (unsigned int i = 0; i <= (poly.order - 1); i++) {
        // we're filling in the ith power of der
        // f(x) = a(i + 1)*x^(i + 1) -> f'(x) = (i + 1)*a(i + 1)*x^i
        der.coeff[i] = field_sum(field, poly.coeff[i + 1], i + 1);
    }
}

field_element_t polynomial_eval(field_t field, polynomial_t poly, field_element_t val) {
    if (val == 0) {
        return poly.coeff[0];
    }

    field_element_t res = 0;

    // we're going to start at 0th order and multiply by val each time
    field_logarithm_t val_exponentiated = field.log[1];
    field_logarithm_t val_log = field.log[val];

    for (unsigned int i = 0; i <= poly.order; i++) {
        if (poly.coeff[i] != 0) {
            // multiply-accumulate by the next coeff times the next power of val
            res = field_add(field, res,
                    field_mul_log_element(field, field.log[poly.coeff[i]], val_exponentiated));
        }
        // now advance to the next power
        val_exponentiated = field_mul_log(field, val_exponentiated, val_log);
    }
    return res;
}

typedef struct {
    size_t block_length;
    size_t message_length;
    size_t min_distance;

    field_t field;

    polynomial_t generator;
    field_element_t *generator_roots;

    polynomial_t encoded_polynomial;
    polynomial_t encoded_remainder;

    field_element_t *syndromes;
    polynomial_t received_polynomial;
    polynomial_t error_locator;
    field_element_t *error_roots;
    field_element_t *error_vals;
    field_logarithm_t *error_locations;

    // scratch
    // (do no allocations at steady state)

    // used during find_error_locator
    polynomial_t last_error_locator;

    // used during error value search
    polynomial_t error_evaluator;
    polynomial_t error_locator_derivative;

} correct_reed_solomon;

// coeff must be of size nroots + 1
// e.g. 2 roots (x + alpha)(x + alpha^2) yields a poly with 3 terms x^2 + g0*x + g1
static void reed_solomon_build_generator(field_t field, unsigned int nroots, polynomial_t generator, field_element_t *roots) {
    // generator has order 2*t
    // of form (x + alpha^1)(x + alpha^2)...(x - alpha^2*t)
    for (unsigned int i = 0; i < nroots; i++) {
        roots[i] = field.exp[i + 2];
    }
    unsigned int order = nroots;
    polynomial_t l;
    l.order = 1;
    l.coeff = calloc(2, sizeof(field_element_t));

    polynomial_t r[2];
    // we'll keep two temporary stores of rightside polynomial
    // each time through the loop, we take the previous result and use it as new rightside
    // swap back and forth (prevents the need for a copy)
    r[0].coeff = calloc(order + 1, sizeof(field_element_t));
    r[1].coeff = calloc(order + 1, sizeof(field_element_t));
    unsigned int rcoeffres = 0;

    // initialize the result with x + roots[0]
    r[rcoeffres].coeff[0] = roots[0];
    r[rcoeffres].coeff[1] = 1;
    r[rcoeffres].order = 1;

    // initialize lcoeff[1] with x
    // we'll fill in the 0th order term in each loop iter
    l.coeff[1] = 1;

    // loop through, using previous run's result as the new right hand side
    // this allows us to multiply one group at a time
    for (unsigned int i = 1; i < nroots; i++) {
        l.coeff[0] = roots[i];
        unsigned int nextrcoeff = rcoeffres;
        rcoeffres = (rcoeffres + 1) % 2;
        r[rcoeffres].order = i + 1;
        polynomial_mul(field, l, r[nextrcoeff], r[rcoeffres]);
    }

    memcpy(generator.coeff, r[rcoeffres].coeff, sizeof(field_element_t) * (order + 1));
    generator.order = order;

    free(l.coeff);
    free(r[0].coeff);
    free(r[1].coeff);
}

correct_reed_solomon *correct_reed_solomon_create(field_operation_t primitive_polynomial) {
    correct_reed_solomon *rs = calloc(1, sizeof(correct_reed_solomon));
    rs->field = field_create(primitive_polynomial);

    rs->block_length = 255;
    rs->message_length = 223;
    rs->min_distance = rs->block_length - rs->message_length;

    rs->generator = polynomial_create(rs->min_distance);
    rs->generator_roots = malloc(rs->min_distance * sizeof(field_element_t));

    reed_solomon_build_generator(rs->field, rs->min_distance, rs->generator, rs->generator_roots);

    rs->encoded_polynomial = polynomial_create(rs->block_length - 1);
    rs->encoded_remainder = polynomial_create(rs->block_length - 1);

    // initialize decoder but don't allocate anything
    rs->syndromes = NULL;

    return rs;
}

ssize_t correct_reed_solomon_encode(correct_reed_solomon *rs, const uint8_t *msg, size_t msg_length, uint8_t *encoded) {
    if (msg_length > rs->message_length) {
        return -1;
    }

    for (unsigned int i = 0; i < msg_length; i++) {
        // message goes from high order to low order but libcorrect polynomials go low to high
        // so we reverse on the way in and on the way out
        // we'd have to do a copy anyway so this reversal should be free
        rs->encoded_polynomial.coeff[rs->encoded_polynomial.order - i] = msg[i];
    }

    // 0-fill the rest of the coefficients -- this length will always be > 0
    // because the order of this poly is block_length and the msg_length <= message_length
    // e.g. 255 and 223
    memset(rs->encoded_polynomial.coeff, 0, (rs->encoded_polynomial.order + 1 - msg_length));

    polynomial_mod(rs->field, rs->encoded_polynomial, rs->generator, rs->encoded_remainder);

    // now return byte order to highest order to lowest order
    for (unsigned int i = 0; i < rs->message_length; i++) {
        encoded[i] = rs->encoded_polynomial.coeff[rs->encoded_polynomial.order - i];
    }

    for (unsigned int i = rs->message_length; i < rs->block_length; i++) {
        encoded[i] = rs->encoded_remainder.coeff[rs->encoded_polynomial.order - i];
    }

    return rs->block_length;
}

static void reed_solomon_find_syndromes(field_t field, polynomial_t msgpoly, const field_element_t *generator_roots, field_element_t *syndromes, size_t min_distance) {
    for (unsigned int i = 0; i < min_distance; i++) {
        syndromes[i] = polynomial_eval(field, msgpoly, generator_roots[i]);
    }
}

// returns number of errors
// Berlekamp-Massey algorithm to find LFSR that describes syndromes
static unsigned int reed_solomon_find_error_locator(correct_reed_solomon *rs) {
    unsigned int numerrors = 0;

    // we'll update a polynomial with order <= syndrome_order
    // this polynomial's cofficients will be multiplied, itemwise,
    //   by the syndromes
    memset(rs->error_locator.coeff, 0, (rs->min_distance + 1) * sizeof(field_element_t));

    // initialize to f(x) = 1
    rs->error_locator.coeff[0] = 1;
    rs->error_locator.order = 0;

    memcpy(rs->last_error_locator.coeff, rs->error_locator.coeff, (rs->min_distance + 1) * sizeof(field_element_t));
    rs->last_error_locator.order = rs->error_locator.order;

    field_element_t discrepancy;
    field_element_t last_discrepancy = 1;
    unsigned int delay_length = 1;

    for (unsigned int i = 0; i < rs->min_distance; i++) {
        discrepancy = rs->syndromes[i];
        for (unsigned int j = 1; j <= rs->error_locator.order; j++) {
            discrepancy = field_add(rs->field, discrepancy, field_mul(rs->field, rs->error_locator.coeff[j], rs->syndromes[i - j]));
        }

        if (!discrepancy) {
            // our existing LFSR describes the new syndrome as well
            // leave it as-is but update the number of delay elements
            //   so that if a discrepancy occurs later we can eliminate it
            delay_length++;
            continue;
        }

        if (2 * numerrors <= i) {
            // there's a discrepancy, but we still have room for more taps
            // lengthen LFSR by one tap and set weight to eliminate discrepancy

            // shift the last locator by the delay length, multiply by discrepancy,
            //   and divide by the last discrepancy
            // we move down because we're shifting up, and this prevents overwriting
            for (int j = rs->last_error_locator.order; j >= 0; j--) {
                // the bounds here will be ok since we have a headroom of numerrors
                rs->last_error_locator.coeff[j + delay_length] = field_div(rs->field, field_mul(rs->field, rs->last_error_locator.coeff[j], discrepancy), last_discrepancy);
            }
            for (int j = delay_length - 1; j >= 0; j--) {
                rs->last_error_locator.coeff[j] = 0;
            }

            // locator = locator - last_locator
            // we will also update last_locator to be locator before this loop takes place
            field_element_t temp;
            for (int j = 0; j <= (rs->last_error_locator.order + delay_length); j++) {
                temp = rs->error_locator.coeff[j];
                rs->error_locator.coeff[j] = field_add(rs->field, rs->error_locator.coeff[j], rs->last_error_locator.coeff[j]);
                rs->last_error_locator.coeff[j] = temp;
            }
            unsigned int temp_order = rs->error_locator.order;
            rs->error_locator.order = rs->last_error_locator.order + delay_length;
            rs->last_error_locator.order = temp_order;

            // now last_locator is locator before we started,
            //   and locator is (locator - (discrepancy/last_discrepancy) * x^(delay_length) * last_locator)

            numerrors = i + 1 - numerrors;
            last_discrepancy = discrepancy;
            delay_length = 1;
            continue;
        }

        // no more taps
        // unlike the previous case, we are preserving last locator,
        //    but we'll update locator as before
        // we're basically flattening the two loops from the previous case because
        //    we no longer need to update last_locator
        for (int j = rs->last_error_locator.order; j >= 0; j--) {
            rs->error_locator.coeff[j + delay_length] = field_add(rs->field, rs->error_locator.coeff[j + delay_length],
                            field_div(rs->field, field_mul(rs->field, rs->last_error_locator.coeff[j], discrepancy),
                            last_discrepancy));
        }
        rs->error_locator.order = rs->last_error_locator.order + delay_length;
        delay_length++;
    }
    return numerrors;
}

// find the roots of the error locator polynomial
// Chien search
bool reed_solomon_factorize_error_locator(field_t field, polynomial_t locator, field_element_t *roots) {
    // normally it'd be tricky to find all the roots
    // but, the finite field is awfully finite...
    // just brute force search across every field element
    unsigned int root = 0;
    for (field_operation_t i = 0; i < 256; i++) {
        if (!polynomial_eval(field, locator, (field_element_t)i)) {
            roots[root] = (field_element_t)i;
            root++;
        }
    }
    // this is where we find out if we are have too many errors to recover from
    // berlekamp-massey may have built an error locator that has 0 discrepancy
    // on the syndromes but doesn't have enough roots
    return root == locator.order;
}

// use error locator and syndromes to find the error evaluator polynomial
void reed_solomon_find_error_evaluator(field_t field, polynomial_t locator, polynomial_t syndromes, polynomial_t error_evaluator) {
    // the error evaluator, omega(x), is S(x)*Lamba(x) mod x^(2t)
    // where S(x) is a polynomial constructed from the syndromes
    //   S(1) + S(2)*x + ... + S(2t)*x(2t - 1)
    // and Lambda(x) is the error locator
    polynomial_mul(field, locator, syndromes, error_evaluator);
}

// use error locator, error roots and syndromes to find the error values
// that is, the elements in the finite field which can be added to the received
//   polynomial at the locations of the error roots in order to produce the
//   transmitted polynomial
// forney algorithm
void reed_solomon_find_error_values(correct_reed_solomon *rs) {
    // error value e(j) = -(X(j)^(1-c) * omega(X(j)^-1))/(lambda'(X(j)^-1))
    // where X(j)^-1 is a root of the error locator, omega(X) is the error evaluator,
    //   lambda'(X) is the first formal derivative of the error locator,
    //   and c is the first consecutive root of the generator used in encoding

    // first find omega(X), the error evaluator
    // we generate S(x), the polynomial constructed from the roots of the syndromes
    // this is *not* the polynomial constructed by expanding the products of roots
    // S(x) = S(1) + S(2)*x + ... + S(2t)*x(2t - 1)
    polynomial_t syndrome_poly;
    syndrome_poly.order = rs->min_distance - 1;
    syndrome_poly.coeff = rs->syndromes;
    reed_solomon_find_error_evaluator(rs->field, rs->error_locator, syndrome_poly, rs->error_evaluator);

    // now find lambda'(X)
    polynomial_formal_derivative(rs->field, rs->error_locator, rs->error_locator_derivative);


    // calculate each e(j)
    for (unsigned int i = 0; i < rs->error_locator.order; i++) {
        // TODO calculate X(j)^(1-c) (presently we assume c = 2 so that X(j)^(1-c) = X(j)^-1)
        rs->error_vals[i] = field_mul(rs->field, rs->error_roots[i], field_div(rs->field,
                polynomial_eval(rs->field, rs->error_evaluator, rs->error_roots[i]),
                polynomial_eval(rs->field, rs->error_locator_derivative, rs->error_roots[i])));
    }
}

void reed_solomon_find_error_locations(field_t field, field_element_t *error_roots, field_logarithm_t *error_locations, unsigned int num_errors) {
    for (unsigned int i = 0; i < num_errors; i++) {
        // the error roots are the reciprocals of the error locations, so div 1 by them

        // we do mod 255 here because the log table aliases at index 1
        // the log of 1 is both 0 and 255 (alpha^255 = alpha^0 = 1)
        // for most uses it makes sense to have log(1) = 255, but in this case
        // we're interested in a byte index, and the 255th index is not even valid
        // just wrap it back to 0

        error_locations[i] = field.log[field_div(field, 1, error_roots[i])] % 255;
    }
}

ssize_t correct_reed_solomon_decode(correct_reed_solomon *rs, const uint8_t *encoded, size_t encoded_length, uint8_t *msg) {
    if (encoded_length != rs->block_length) {
        return -1;
    }

    if (!rs->syndromes) {
        // initialize rs for decoding
        rs->syndromes = calloc(rs->min_distance, sizeof(field_element_t));
        rs->received_polynomial = polynomial_create(rs->block_length - 1);
        rs->error_locator = polynomial_create(rs->min_distance);
        rs->error_roots = calloc(rs->min_distance, sizeof(field_element_t));
        rs->error_vals = malloc(rs->min_distance * sizeof(field_element_t));
        rs->error_locations = malloc(rs->min_distance * sizeof(field_logarithm_t));

        rs->last_error_locator = polynomial_create(rs->min_distance);
        rs->error_evaluator = polynomial_create(rs->min_distance - 1);
        rs->error_locator_derivative = polynomial_create(rs->min_distance - 1);
    }

    // copy in and flip order
    for (unsigned int i = 0; i < rs->block_length; i++) {
        rs->received_polynomial.coeff[i] = encoded[rs->received_polynomial.order - i];
    }

    reed_solomon_find_syndromes(rs->field, rs->received_polynomial, rs->generator_roots, rs->syndromes, rs->min_distance);

    unsigned int numerrors = reed_solomon_find_error_locator(rs);
    // XXX fix this vvvv
    rs->error_locator.order = numerrors;

    if (!reed_solomon_factorize_error_locator(rs->field, rs->error_locator, rs->error_roots)) {
        return -1;
    }

    reed_solomon_find_error_values(rs);

    reed_solomon_find_error_locations(rs->field, rs->error_roots, rs->error_locations, rs->error_locator.order);

    for (unsigned int i = 0; i < rs->error_locator.order; i++) {
        rs->received_polynomial.coeff[rs->error_locations[i]] = field_sub(rs->field, rs->received_polynomial.coeff[rs->error_locations[i]], rs->error_vals[i]);
    }

    // TODO recalculate syndromes, check for zero (only if numerrors = min_distance?)

    for (unsigned int i = 0; i < rs->message_length; i++) {
        msg[i] = rs->received_polynomial.coeff[(rs->block_length - i) - 1];
    }

    return rs->message_length;
}

void correct_reed_solomon_destroy(correct_reed_solomon *rs) {
    field_destroy(rs->field);
    polynomial_destroy(rs->generator);
    free(rs->generator_roots);
    polynomial_destroy(rs->encoded_polynomial);
    polynomial_destroy(rs->encoded_remainder);
    if (rs->syndromes) {
        free(rs->syndromes);
        polynomial_destroy(rs->received_polynomial);
        polynomial_destroy(rs->error_locator);
        free(rs->error_roots);
        free(rs->error_vals);
        free(rs->error_locations);
        polynomial_destroy(rs->last_error_locator);
        polynomial_destroy(rs->error_evaluator);
        polynomial_destroy(rs->error_locator_derivative);
    }
    free(rs);
}


int main() {

    field_t field = field_create(primitive_polynomial_ccsds);

    for (unsigned int i = 0; i < 256; i++) {
        printf("%3d  %3d    %3d  %3d\n", i, field.exp[i], i, field.log[i]);
    }

    printf("\n");

    correct_reed_solomon *rs = correct_reed_solomon_create(primitive_polynomial_ccsds);

    printf("roots: ");
    for (unsigned int i = 0; i < rs->min_distance; i++) {
        printf("%d", rs->generator_roots[i]);
        if (i < rs->min_distance - 1) {
            printf(", ");
        }
    }
    printf("\n\n");

    printf("generator: ");
    for (unsigned int i = 0; i < rs->generator.order + 1; i++) {
        printf("%d*x^%d", rs->generator.coeff[i], i);
        if (i < rs->generator.order) {
            printf(" + ");
        }
    }
    printf("\n\n");

    printf("generator (alpha format): ");
    for (unsigned int i = rs->generator.order + 1; i > 0; i--) {
        printf("alpha^%d*x^%d", rs->field.log[rs->generator.coeff[i - 1]], i - 1);
        if (i > 1) {
            printf(" + ");
        }
    }
    printf("\n\n");

    unsigned char *msg = calloc(rs->message_length, sizeof(unsigned char));
    for (unsigned char i = 0; i < rs->message_length; i++) {
        msg[i] = i;
    }

    uint8_t *encoded = malloc(rs->block_length * sizeof(uint8_t));
    correct_reed_solomon_encode(rs, msg, rs->message_length, encoded);

    printf("remainder: ");
    bool has_printed = false;
    for (unsigned int i = 0; i < rs->encoded_remainder.order + 1; i++) {
        if (!rs->encoded_remainder.coeff[i]) {
            continue;
        }
        if (has_printed) {
            printf(" + ");
        }
        has_printed = true;
        printf("%d*x^%d", rs->encoded_remainder.coeff[i], i);
    }
    printf("\n\n");

    polynomial_t msgpoly;
    msgpoly.coeff = malloc(rs->block_length * sizeof(field_element_t));
    msgpoly.order = rs->block_length - 1;

    for (unsigned int i = 0; i < rs->block_length; i++) {
        msgpoly.coeff[i] = encoded[rs->block_length - i - 1];
    }

    field_element_t *syndromes = calloc(rs->min_distance, sizeof(field_element_t));
    reed_solomon_find_syndromes(field, msgpoly, rs->generator_roots, syndromes, rs->min_distance);

    printf("syndromes: ");
    for (unsigned int i = 0; i < rs->min_distance; i++) {
        printf("%d", syndromes[i]);
        if (i < rs->min_distance - 1) {
            printf(", ");
        }
    }
    printf("\n\n");

    srand(time(NULL));
    float p = 0.06;
    unsigned int corrupted = 0;
    printf("corrupted bytes at: ");
    has_printed = false;
    for (unsigned int i = 0; i < msgpoly.order + 1; i++) {
        if (rand()/(float)RAND_MAX > (1 - p) || (i == 0)) {
            if (has_printed) {
                printf(", ");
            }
            has_printed = true;
            uint8_t corruption_mask = (32 - corrupted);
            msgpoly.coeff[i] ^= corruption_mask;
            corrupted++;
            printf("%d@%d", corruption_mask, i);
        }
    }
    printf(" (%d bytes)\n\n", corrupted);

    reed_solomon_find_syndromes(field, msgpoly, rs->generator_roots, syndromes, rs->min_distance);

    printf("syndromes (corrupted): ");
    for (unsigned int i = 0; i < rs->min_distance; i++) {
        printf("%d", syndromes[i]);
        if (i < rs->min_distance - 1) {
            printf(", ");
        }
    }
    printf("\n\n");

    for (unsigned int i = 0; i < rs->block_length; i++) {
        encoded[i] = msgpoly.coeff[rs->block_length - i - 1];
    }

    unsigned char *recvmsg = malloc(sizeof(unsigned char) * rs->message_length);

    if (correct_reed_solomon_decode(rs, encoded, rs->block_length, recvmsg) == -1) {
        printf("decoding failed\n");
        return 0;
    }

    printf("numerrors: %d\n\n", rs->error_locator.order);

    printf("error locator: ");
    has_printed = false;
    for (unsigned int i = 0; i < rs->error_locator.order + 1; i++) {
        if (!rs->error_locator.coeff[i]) {
            continue;
        }
        if (has_printed) {
            printf(" + ");
        }
        has_printed = true;
        printf("%d*x^%d", rs->error_locator.coeff[i], i);
    }
    printf("\n\n");

    printf("error locator: ");
    for (unsigned int i = 0; i < rs->error_locator.order; i++) {
        printf("%d@%d", rs->error_vals[i], rs->error_locations[i]);
        if (i < rs->error_locator.order - 1) {
            printf(", ");
        }
    }
    printf("\n\n");

    printf("decoded matches original: ");
    bool match = (memcmp(msg, recvmsg, rs->message_length) == 0);
    if (match) {
        printf("true");
    } else {
        printf("false");
    }
    printf("\n");


    free(encoded);
    correct_reed_solomon_destroy(rs);
    free(recvmsg);
    free(syndromes);
    free(msgpoly.coeff);
    free(msg);
    field_destroy(field);
    return 0;
}
