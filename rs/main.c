#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>

// an element in GF(2^8)
typedef uint8_t field_element_t;

// a power of the primitive element alpha
typedef uint8_t field_logarithm_t;

// give us some bits of headroom to do arithmetic
// variables of this type aren't really in any proper space
typedef uint16_t field_operation_t;

// generated by find_poly
const field_operation_t primitive_polynomial_8_4_3_2_0 = 0x11d;  // x^8 + x^4 + x^3 + x^2 + 1
const field_operation_t primitive_polynomial_8_5_3_1_0 = 0x12b;  // x^8 + x^5 + x^3 + x + 1
const field_operation_t primitive_polynomial_8_5_3_2_0 = 0x12d;  // x^8 + x^5 + x^3 + x^2 + 1
const field_operation_t primitive_polynomial_8_6_3_2_0 = 0x14d;  // x^8 + x^6 + x^3 + x^2 + 1
const field_operation_t primitive_polynomial_8_6_4_3_2_1_0 = 0x15f;  // x^8 + x^6 + x^4 + x^3 + x^2 + x + 1;
const field_operation_t primitive_polynomial_8_6_5_1_0 = 0x163;  // x^8 + x^6 + x^5 + x + 1
const field_operation_t primitive_polynomial_8_6_5_2_0 = 0x165;  // x^8 + x^6 + x^5 + x^2 + 1
const field_operation_t primitive_polynomial_8_6_5_3_0 = 0x169;  // x^8 + x^6 + x^5 + x^3 + 1
const field_operation_t primitive_polynomial_8_6_5_4_0 = 0x171;  // x^8 + x^6 + x^5 + x^4 + 1
const field_operation_t primitive_polynomial_8_7_2_1_0 = 0x187;  // x^8 + x^7 + x^2 + x + 1
const field_operation_t primitive_polynomial_8_7_3_2_0 = 0x18d;  // x^8 + x^7 + x^3 + x^2 + 1
const field_operation_t primitive_polynomial_8_7_5_3_0 = 0x1a9;  // x^8 + x^7 + x^5 + x^3 + 1
const field_operation_t primitive_polynomial_8_7_6_1_0 = 0x1c3;  // x^8 + x^7 + x^6 + x + 1
const field_operation_t primitive_polynomial_8_7_6_3_2_1_0 = 0x1cf;  // x^8 + x^7 + x^6 + x^3 + x^2 + x + 1
const field_operation_t primitive_polynomial_8_7_6_5_2_1_0 = 0x1e7;  // x^8 + x^7 + x^6 + x^5 + x^2 + x + 1
const field_operation_t primitive_polynomial_8_7_6_5_4_2_0 = 0x1f5;  // x^8 + x^7 + x^6 + x^5 + x^4 + x^2 + 1

const field_operation_t primitive_polynomial_ccsds = primitive_polynomial_8_7_2_1_0;

typedef struct {
    const field_element_t *exp;
    const field_logarithm_t *log;
} field_t;

field_t field_create(field_operation_t poly) {
    // in GF(2^8)
    // log and exp
    // bits are in GF(2), compute alpha^val in GF(2^8)
    // exp should be of size 512 so that it can hold a "wraparound" which prevents some modulo ops
    // log should be of size 256. no wraparound here, the indices into this table are field elements
    field_element_t *exp = malloc(512 * sizeof(field_element_t));
    field_logarithm_t *log = malloc(256 * sizeof(field_logarithm_t));

    // assume alpha is a primitive element, p(x) irreducible in GF(2^8)
    // addition is xor
    // subtraction is addition (also xor)
    // e.g. x^5 + x^4 + x^4 + x^2 + 1 = x^5 + x^2 + 1
    // each row of exp contains the field element found by exponentiating
    //   alpha by the row index
    // each row of log contains the coefficients of
    //   alpha^7 + alpha^6 + alpha^5 + alpha^4 + alpha^3 + alpha^2 + alpha + 1
    // as 8 bits packed into one byte

    field_operation_t element = 1;
    exp[0] = (field_element_t)element;
    log[0] = (field_logarithm_t)0;  // really, it's undefined. we shouldn't ever access this
    for (field_operation_t i = 1; i < 512; i++) {
        element = element * 2;
        element = (element > 255) ? (element ^ poly) : element;
        exp[i] = (field_element_t)element;
        if (i < 256) {
            log[element] = (field_logarithm_t)i;
        }
    }

    field_t field;
    *(field_element_t **)&field.exp = exp;
    *(field_logarithm_t **)&field.log = log;

    return field;
}

void field_destroy(field_t field) {
    free(*(field_element_t **)&field.exp);
    free(*(field_element_t **)&field.log);
}

field_element_t field_add(field_t field, field_element_t l, field_element_t r) {
    return l ^ r;
}

field_element_t field_sub(field_t field, field_element_t l, field_element_t r) {
    return l ^ r;
}

field_element_t field_sum(field_t field, field_element_t elem, unsigned int n) {
    // we'll do a closed-form expression of the sum, although we could also
    //   choose to call field_add n times

    // since the sum is actually the bytewise XOR operator, this suggests two
    // kinds of values: n odd, and n even

    // if you sum once, you have coeff
    // if you sum twice, you have coeff XOR coeff = 0
    // if you sum thrice, you are back at coeff
    // an even number of XORs puts you at 0
    // an odd number of XORs puts you back at your value

    // so, just throw away all the even n
    return (n % 2) ? elem : 0;
}

field_element_t field_mul(field_t field, field_element_t l, field_element_t r) {
    if (l == 0 || r == 0) {
        return 0;
    }
    // multiply two field elements by adding their logarithms.
    // yep, get your slide rules out
    field_operation_t res = (field_operation_t)field.log[l] + (field_operation_t)field.log[r];

    // if coeff exceeds 255, we would normally have to wrap it back around
    // alpha^255 = 1; alpha^256 = alpha^255 * alpha^1 = alpha^1
    // however, we've constructed exponentiation table so that
    //   we can just directly lookup this result
    // the result must be clamped to [0, 511]
    // the greatest we can see at this step is alpha^255 * alpha^255
    //   = alpha^510
    return field.exp[res];
}

field_element_t field_div(field_t field, field_element_t l, field_element_t r) {
    if (l == 0) {
        return 0;
    }

    if (r == 0) {
        // XXX ???
        return 0;
    }

    // division as subtraction of logarithms

    // if rcoeff is larger, then log[l] - log[r] wraps under
    // so, instead, always add 255. in some cases, we'll wrap over, but
    // that's ok because the exp table runs up to 511.
    field_operation_t res = (field_operation_t)255 + (field_operation_t)field.log[l] - (field_operation_t)field.log[r];
    return field.exp[res];
}

field_logarithm_t field_mul_log(field_t field, field_logarithm_t l, field_logarithm_t r) {
    field_operation_t res = (field_operation_t)l + (field_operation_t)r;
    if (res > 255) {
        return (field_logarithm_t)(res - 255);
    }
    return (field_logarithm_t)res;
}

field_logarithm_t field_div_log(field_t field, field_logarithm_t l, field_logarithm_t r) {
    field_operation_t res = (field_operation_t)255 + (field_operation_t)l - (field_operation_t)r;
    if (res > 255) {
        return (field_logarithm_t)(res - 255);
    }
    return (field_logarithm_t)res;
}

field_element_t field_mul_log_element(field_t field, field_logarithm_t l, field_logarithm_t r) {
    field_operation_t res = (field_operation_t)l + (field_operation_t)r;
    return field.exp[res];
}

/*
unsigned short powcoeff(unsigned short coeff, unsigned int pow, const unsigned short *exp,
                        const unsigned short *log) {
    // take the logarithm, multiply, and then "exponentiate"
    // n.b. the exp table only considers powers of alpha, the primitive element
    // but here we have an arbitray coeff
    coeff = log[coeff];
    unsigned int rescoeff = coeff * pow;
    unsigned int nwraps = rescoeff / 256;
    unsigned int mod = rescoeff % 256;
    nwraps = (mod > 0) ? nwraps + 1 : nwraps;
    rescoeff = mod

}
*/

typedef struct {
    field_element_t *coeff;
    unsigned int order;
} polynomial_t;

// if you want a full multiplication, then make res.order = l.order + r.order
// but if you just care about a lower order, e.g. mul mod x^i, then you can select
//    fewer coefficients
void polynomial_mul(field_t field, polynomial_t l, polynomial_t r, polynomial_t res) {
    memset(res.coeff, 0, sizeof(field_element_t) * (res.order + 1));
    for (unsigned int i = 0; i <= l.order; i++) {
        if (i > res.order) {
            continue;
        }
        unsigned int j_limit = (r.order > res.order - i) ? res.order - i : r.order;
        for (unsigned int j = 0; j <= j_limit; j++) {
            // e.g. alpha^5*x * alpha^37*x^2 --> alpha^42*x^3
            res.coeff[i + j] = field_add(field, res.coeff[i + j], field_mul(field, l.coeff[i], r.coeff[j]));
        }
    }
}

void polynomial_mod(field_t field, polynomial_t dividend, polynomial_t divisor, polynomial_t mod) {
    // do long division and return just the remainder

    if (mod.order < dividend.order) {
        printf("polynomial_mod: mod.order must be >= dividend.order (scratch space needed)");
        return;
    }
    // initialize remainder as dividend
    memcpy(mod.coeff, dividend.coeff, sizeof(field_element_t) * (dividend.order + 1));

    // XXX make sure divisor[divisor_order] is nonzero
    field_logarithm_t divisor_leading = field.log[divisor.coeff[divisor.order]];
    // long division steps along one order at a time, starting at the highest order
    for (unsigned int i = dividend.order; i > 0; i--) {
        // look at the leading coefficient of dividend and divisor
        // if leading coefficient of dividend / leading coefficient of divisor is q
        //   then the next row of subtraction will be q * divisor
        // if order of q < 0 then what we have is the remainder and we are done
        if (i < divisor.order) {
            break;
        }
        if (mod.coeff[i] == 0) {
            continue;
        }
        unsigned int q_order = i - divisor.order;
        field_logarithm_t q_coeff = field_div_log(field, field.log[mod.coeff[i]], divisor_leading);

        // now that we've chosen q, multiply the divisor by q and subtract from
        //   our remainder. subtracting in GF(2^8) is XOR, just like addition
        for (unsigned int j = 0; j <= divisor.order; j++) {
            if (divisor.coeff[j] == 0) {
                continue;
            }
            // all of the multiplication is shifted up by q_order places
            mod.coeff[j + q_order] = field_add(field, mod.coeff[j + q_order],
                        field_mul_log_element(field, field.log[divisor.coeff[j]], q_coeff));
        }
    }
}

void polynomial_formal_derivative(field_t field, polynomial_t poly, polynomial_t der) {
    // if f(x) = a(n)*x^n + ... + a(1)*x + a(0)
    // then f'(x) = n*a(n)*x^(n-1) + ... + 2*a(2)*x + a(1)
    // where n*a(n) = sum(k=1, n, a(n)) e.g. the nth sum of a(n) in GF(2^8)

    // assumes der.order = poly.order - 1
    memset(der.coeff, 0, sizeof(field_element_t) * poly.order);
    for (unsigned int i = 0; i <= (poly.order - 1); i++) {
        // we're filling in the ith power of der
        // f(x) = a(i + 1)*x^(i + 1) -> f'(x) = (i + 1)*a(i + 1)*x^i
        der.coeff[i] = field_sum(field, poly.coeff[i + 1], i + 1);
    }
}

field_element_t polynomial_eval(field_t field, polynomial_t poly, field_element_t val) {
    if (val == 0) {
        return poly.coeff[0];
    }

    field_element_t res = 0;

    // we're going to start at 0th order and multiply by val each time
    field_logarithm_t val_exponentiated = field.log[1];
    field_logarithm_t val_log = field.log[val];

    for (unsigned int i = 0; i <= poly.order; i++) {
        if (poly.coeff[i] != 0) {
            // multiply-accumulate by the next coeff times the next power of val
            res = field_add(field, res,
                    field_mul_log_element(field, field.log[poly.coeff[i]], val_exponentiated));
        }
        // now advance to the next power
        val_exponentiated = field_mul_log(field, val_exponentiated, val_log);
    }
    return res;
}

// coeff must be of size nroots + 1
// e.g. 2 roots (x + alpha)(x + alpha^2) yields a poly with 3 terms x^2 + g0*x + g1
void buildgenerator(field_t field, unsigned int nroots, polynomial_t generator, field_element_t *roots) {
    // generator has order 2*t
    // of form (x + alpha^1)(x + alpha^2)...(x - alpha^2*t)
    for (unsigned int i = 0; i < nroots; i++) {
        roots[i] = field.exp[i + 2];
    }
    unsigned int order = nroots;
    polynomial_t l;
    l.order = 1;
    l.coeff = calloc(2, sizeof(field_element_t));

    polynomial_t r[2];
    // we'll keep two temporary stores of rightside polynomial
    // each time through the loop, we take the previous result and use it as new rightside
    // swap back and forth (prevents the need for a copy)
    r[0].coeff = calloc(order + 1, sizeof(field_element_t));
    r[1].coeff = calloc(order + 1, sizeof(field_element_t));
    unsigned int rcoeffres = 0;

    // initialize the result with x + roots[0]
    r[rcoeffres].coeff[0] = roots[0];
    r[rcoeffres].coeff[1] = 1;
    r[rcoeffres].order = 1;

    // initialize lcoeff[1] with x
    // we'll fill in the 0th order term in each loop iter
    l.coeff[1] = 1;

    // loop through, using previous run's result as the new right hand side
    // this allows us to multiply one group at a time
    for (unsigned int i = 1; i < nroots; i++) {
        l.coeff[0] = roots[i];
        unsigned int nextrcoeff = rcoeffres;
        rcoeffres = (rcoeffres + 1) % 2;
        r[rcoeffres].order = i + 1;
        polynomial_mul(field, l, r[nextrcoeff], r[rcoeffres]);
    }

    memcpy(generator.coeff, r[rcoeffres].coeff, sizeof(field_element_t) * (order + 1));
    generator.order = order;

    free(l.coeff);
    free(r[0].coeff);
    free(r[1].coeff);
}

// returns number of errors
// Berlekamp-Massey algorithm to find LFSR that describes syndromes
unsigned int finderrorlocator(field_t field, field_element_t *syndromes, unsigned int syndrome_order, polynomial_t locator) {
    unsigned int numerrors = 0;

    // we'll update a polynomial with order <= syndrome_order
    // this polynomial's cofficients will be multiplied, itemwise,
    //   by the syndromes
    memset(locator.coeff, 0, syndrome_order * sizeof(field_element_t));

    // initialize to f(x) = 1
    locator.coeff[0] = 1;
    locator.order = 0;

    polynomial_t last_locator;
    last_locator.coeff = malloc(syndrome_order * sizeof(field_element_t));
    memcpy(last_locator.coeff, locator.coeff, syndrome_order * sizeof(field_element_t));
    last_locator.order = locator.order;

    field_element_t last_discrepancy = 1;
    unsigned int delay_length = 1;

    for (unsigned int i = 0; i < syndrome_order; i++) {
        field_element_t discrepancy = syndromes[i];
        for (unsigned int j = 1; j <= locator.order; j++) {
            discrepancy = field_add(field, discrepancy, field_mul(field, locator.coeff[j], syndromes[i - j]));
        }

        if (!discrepancy) {
            // our existing LFSR describes the new syndrome as well
            // leave it as-is but update the number of delay elements
            //   so that if a discrepancy occurs later we can eliminate it
            delay_length++;
            continue;
        }

        if (2 * numerrors <= i) {
            // there's a discrepancy, but we still have room for more taps
            // lengthen LFSR by one tap and set weight to eliminate discrepancy

            // shift the last locator by the delay length, multiply by discrepancy,
            //   and divide by the last discrepancy
            // we move down because we're shifting up, and this prevents overwriting
            for (int j = last_locator.order; j >= 0; j--) {
                // the bounds here will be ok since we have a headroom of numerrors
                last_locator.coeff[j + delay_length] = field_div(field, field_mul(field, last_locator.coeff[j], discrepancy), last_discrepancy);
            }
            for (int j = delay_length - 1; j >= 0; j--) {
                last_locator.coeff[j] = 0;
            }

            // locator = locator - last_locator
            // we will also update last_locator to be locator before this loop takes place
            field_element_t temp;
            for (int j = 0; j <= (last_locator.order + delay_length); j++) {
                temp = locator.coeff[j];
                locator.coeff[j] = field_add(field, locator.coeff[j], last_locator.coeff[j]);
                last_locator.coeff[j] = temp;
            }
            unsigned int temp_order = locator.order;
            locator.order = last_locator.order + delay_length;
            last_locator.order = temp_order;

            // now last_locator is locator before we started,
            //   and locator is (locator - (discrepancy/last_discrepancy) * x^(delay_length) * last_locator)

            numerrors = i + 1 - numerrors;
            last_discrepancy = discrepancy;
            delay_length = 1;
            continue;
        }

        // no more taps
        // unlike the previous case, we are preserving last locator,
        //    but we'll update locator as before
        // we're basically flattening the two loops from the previous case because
        //    we no longer need to update last_locator
        for (int j = last_locator.order; j >= 0; j--) {
            locator.coeff[j + delay_length] = field_add(field, locator.coeff[j + delay_length],
                            field_div(field, field_mul(field, last_locator.coeff[j], discrepancy),
                            last_discrepancy));
        }
        locator.order = last_locator.order + delay_length;
        delay_length++;
    }
    free(last_locator.coeff);
    return numerrors;
}

// find the roots of the error locator polynomial
// Chien search
void factorizeerrorlocator(field_t field, polynomial_t locator, field_element_t *roots) {
    // normally it'd be tricky to find all the roots
    // but, the finite field is awfully finite...
    // just brute force search across every field element
    unsigned int root = 0;
    for (field_operation_t i = 0; i < 256; i++) {
        if (!polynomial_eval(field, locator, (field_element_t)i)) {
            roots[root] = (field_element_t)i;
            root++;
        }
    }
}

// use error locator and syndromes to find the error evaluator polynomial
void finderrorevaluator(field_t field, polynomial_t locator, polynomial_t syndromes, polynomial_t errorevaluator) {
    // the error evaluator, omega(x), is S(x)*Lamba(x) mod x^(2t)
    // where S(x) is a polynomial constructed from the syndromes
    //   S(1) + S(2)*x + ... + S(2t)*x(2t - 1)
    // and Lambda(x) is the error locator
    polynomial_mul(field, locator, syndromes, errorevaluator);
}

// use error locator, error roots and syndromes to find the error values
// that is, the elements in the finite field which can be added to the received
//   polynomial at the locations of the error roots in order to produce the
//   transmitted polynomial
void finderrorvalues(field_t field, polynomial_t locator, field_element_t *syndromes,
                     field_element_t *errorvals, const field_element_t *errorroots, unsigned int numerrors) {
    polynomial_t syndrome_poly;
    syndrome_poly.order = 32;
    syndrome_poly.coeff = syndromes;

    unsigned int deriv_order = locator.order - 1;
    polynomial_t errorderiv;
    errorderiv.coeff = malloc(sizeof(field_element_t) * (deriv_order + 1));
    errorderiv.order = deriv_order;
    polynomial_formal_derivative(field, locator, errorderiv);

    polynomial_t errorevaluator;
    errorevaluator.coeff = malloc(sizeof(field_element_t) * (31 + 1));
    errorevaluator.order = 31;
    finderrorevaluator(field, locator, syndrome_poly, errorevaluator);

    for (unsigned int i = 0; i < numerrors; i++) {
        errorvals[i] = field_mul(field, errorroots[i], field_div(field,
                polynomial_eval(field, errorevaluator, errorroots[i]),
                polynomial_eval(field, errorderiv, errorroots[i])));
    }

    free(errorderiv.coeff);
    free(errorevaluator.coeff);
}

int main() {

    field_t field = field_create(primitive_polynomial_ccsds);

    for (unsigned int i = 0; i < 256; i++) {
        printf("%3d  %3d    %3d  %3d\n", i, field.exp[i], i, field.log[i]);
    }

    printf("\n");

    polynomial_t generator;
    generator.coeff = malloc(sizeof(field_element_t) * 33);
    field_element_t *genroots = malloc(sizeof(field_element_t) * 32);

    buildgenerator(field, 32, generator, genroots);

    printf("roots: ");
    for (unsigned int i = 0; i < 32; i++) {
        printf("%d", genroots[i]);
        if (i < 32) {
            printf(", ");
        }
    }
    printf("\n\n");

    printf("generator: ");
    for (unsigned int i = 0; i < generator.order + 1; i++) {
        printf("%d*x^%d", generator.coeff[i], i);
        if (i < generator.order) {
            printf(" + ");
        }
    }
    printf("\n\n");

    printf("generator (alpha format): ");
    for (unsigned int i = generator.order + 1; i > 0; i--) {
        printf("alpha^%d*x^%d", field.log[generator.coeff[i - 1]], i - 1);
        if (i > 1) {
            printf(" + ");
        }
    }
    printf("\n\n");

    unsigned char *msg = calloc(223, sizeof(unsigned char));
    for (unsigned char i = 0; i < 223; i++) {
        msg[i] = i;
    }

    polynomial_t msgpoly;
    msgpoly.coeff = calloc(255, sizeof(field_element_t));
    msgpoly.order = 254;
    for (unsigned int i = 0; i < 223; i++) {
        msgpoly.coeff[msgpoly.order - i] = msg[i];
    }
    polynomial_t rem;
    rem.coeff = calloc(255, sizeof(field_element_t));
    rem.order = generator.order;
    polynomial_mod(field, msgpoly, generator, rem);

    printf("remainder: ");
    bool has_printed = false;
    for (unsigned int i = 0; i < rem.order + 1; i++) {
        if (!rem.coeff[i]) {
            continue;
        }
        if (has_printed) {
            printf(" + ");
        }
        has_printed = true;
        printf("%d*x^%d", rem.coeff[i], i);
    }
    printf("\n\n");

    for (unsigned int i = 0; i < 32; i++) {
        msgpoly.coeff[i] = rem.coeff[i];
    }

    field_element_t *syndromes = calloc(32, sizeof(field_element_t));
    for (unsigned int i = 0; i < 32; i++) {
        syndromes[i] = polynomial_eval(field, msgpoly, genroots[i]);
    }

    printf("syndromes: ");
    for (unsigned int i = 0; i < 32; i++) {
        printf("%d", syndromes[i]);
        if (i < 31) {
            printf(", ");
        }
    }
    printf("\n\n");

    srand(time(NULL));
    float p = 0.04;
    unsigned int corrupted = 0;
    printf("corrupted bytes at: ");
    has_printed = false;
    for (unsigned int i = 0; i < msgpoly.order + 1; i++) {
        if (rand()/(float)RAND_MAX > (1 - p) || (i == 0)) {
            if (has_printed) {
                printf(", ");
            }
            has_printed = true;
            uint8_t corruption_mask = (32 - corrupted);
            msgpoly.coeff[i] ^= corruption_mask;
            corrupted++;
            printf("%d@%d", corruption_mask, i);
        }
    }
    printf(" (%d bytes)\n\n", corrupted);

    for (unsigned int i = 0; i < 32; i++) {
        syndromes[i] = polynomial_eval(field, msgpoly, genroots[i]);
    }

    printf("syndromes (corrupted): ");
    for (unsigned int i = 0; i < 32; i++) {
        printf("%d", syndromes[i]);
        if (i < 31) {
            printf(", ");
        }
    }
    printf("\n\n");

    polynomial_t errorlocator;
    errorlocator.coeff = calloc(32, sizeof(field_element_t));
    unsigned int numerrors = finderrorlocator(field, syndromes, 32, errorlocator);
    // XXX fix this vvvv
    errorlocator.order = numerrors;

    printf("numerrors: %d\n\n", numerrors);

    printf("error locator: ");
    has_printed = false;
    for (unsigned int i = 0; i < errorlocator.order + 1; i++) {
        if (!errorlocator.coeff[i]) {
            continue;
        }
        if (has_printed) {
            printf(" + ");
        }
        has_printed = true;
        printf("%d*x^%d", errorlocator.coeff[i], i);
    }
    printf("\n\n");

    field_element_t *errorroots = calloc(numerrors, sizeof(field_element_t));
    factorizeerrorlocator(field, errorlocator, errorroots);

    field_element_t *errorvals = malloc(sizeof(field_element_t) * numerrors);
    finderrorvalues(field, errorlocator, syndromes, errorvals, errorroots, numerrors);

    for (unsigned int i = 0; i < numerrors; i++) {
        errorroots[i] = field.log[field_div(field, 1, errorroots[i])];
    }

    printf("error locator: ");
    for (unsigned int i = 0; i < numerrors; i++) {
        printf("%d@%d", errorvals[i], errorroots[i]);
        if (i < numerrors - 1) {
            printf(", ");
        }
    }
    printf("\n\n");

    field_element_t *decpoly = malloc(sizeof(field_element_t) * 255);
    memcpy(decpoly, msgpoly.coeff, 255 * sizeof(field_element_t));
    for (unsigned int i = 0; i < numerrors; i++) {
        decpoly[errorroots[i]] ^= errorvals[i];
    }

    unsigned char *recvmsg = malloc(sizeof(unsigned char) * 223);
    for (unsigned int i = 0; i < 223; i++) {
        recvmsg[i] = decpoly[(255 - i) - 1];
    }

    printf("decoded matches original: ");
    bool match = (strncmp((char *)msg, (char *)recvmsg, 223) == 0);
    if (match) {
        printf("true");
    } else {
        printf("false");
    }
    printf("\n");


    free(recvmsg);
    free(decpoly);
    free(errorvals);
    free(errorroots);
    free(errorlocator.coeff);
    free(syndromes);
    free(rem.coeff);
    free(msgpoly.coeff);
    free(msg);
    free(generator.coeff);
    free(genroots);
    field_destroy(field);
    return 0;
}
